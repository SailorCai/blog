(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{377:function(s,a,t){"use strict";t.r(a);var r=t(42),e=Object(r.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"dockerfile-常用指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile-常用指令"}},[s._v("#")]),s._v(" Dockerfile 常用指令")]),s._v(" "),t("p",[s._v("docker 依据 Dockerfile 文件构建镜像，当你需要定制镜像的时候就会用到")]),s._v(" "),t("h3",{attrs:{id:"from"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#from"}},[s._v("#")]),s._v(" FROM")]),s._v(" "),t("p",[s._v("FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。")]),s._v(" "),t("h3",{attrs:{id:"run"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#run"}},[s._v("#")]),s._v(" RUN")]),s._v(" "),t("p",[s._v("RUN：用于执行后面跟着的命令行命令。有以下两种格式：")]),s._v(" "),t("p",[t("strong",[s._v("shell 格式：")])]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("RUN "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("命令行命令"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# <命令行命令> 等同于，在终端操作的 shell 命令。")]),s._v("\n")])])]),t("p",[t("strong",[s._v("exec 格式：")])]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("RUN "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"可执行文件"')]),s._v(", "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"参数1"')]),s._v(", "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"参数2"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 例如：")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v('# RUN ["./test.php", "dev", "offline"] 等价于 RUN ./test.php dev offline')]),s._v("\n")])])]),t("h3",{attrs:{id:"cmd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[s._v("#")]),s._v(" CMD")]),s._v(" "),t("p",[s._v("类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:")]),s._v(" "),t("blockquote",[t("p",[s._v("CMD 在 docker run 时运行。\nRUN 是在 docker build。")])]),s._v(" "),t("p",[s._v("作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。")]),s._v(" "),t("p",[s._v("注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。")]),s._v(" "),t("p",[s._v("格式：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("CMD "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("shell 命令"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\nCMD "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"<可执行文件或命令>"')]),s._v(","),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"<param1>"')]),s._v(","),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"<param2>"')]),s._v(","),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\nCMD "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"<param1>"')]),s._v(","),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"<param2>"')]),s._v(","),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数")]),s._v("\n")])])]),t("p",[s._v("推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。")]),s._v(" "),t("h3",{attrs:{id:"copy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copy"}},[s._v("#")]),s._v(" COPY")]),s._v(" "),t("p",[s._v("复制指令，从上下文目录中复制文件或者目录到容器里指定路径。")]),s._v(" "),t("p",[s._v("格式：")]),s._v(" "),t("blockquote",[t("p",[s._v("COPY [--chown="),t("user",[s._v(":"),t("group",[s._v("] <源路径 1>... <目标路径>\nCOPY [--chown="),t("user",[s._v(":"),t("group",[s._v('] ["<源路径 1>",... "<目标路径>"]。\n[--chown='),t("user",[s._v(":"),t("group",[s._v("]：可选参数，用户改变复制到容器内文件的拥有者和属组。")])],1)],1)],1)],1)],1)],1)]),s._v(" "),t("p",[s._v("<源路径>：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("COPY hom* /mydir/\nCOPY hom?.txt /mydir/\n")])])]),t("p",[s._v("<目标路径>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。")]),s._v(" "),t("h3",{attrs:{id:"add"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#add"}},[s._v("#")]),s._v(" ADD")]),s._v(" "),t("p",[s._v("ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：")]),s._v(" "),t("blockquote",[t("p",[s._v("ADD 的优点：在执行 <源文件> 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 <目标路径>。\nADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。")])]),s._v(" "),t("h3",{attrs:{id:"env"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#env"}},[s._v("#")]),s._v(" ENV")]),s._v(" "),t("p",[s._v("设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。")]),s._v(" "),t("p",[s._v("格式：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("ENV "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("key"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("value"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\nENV "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("key"),t("span",{pre:!0,attrs:{class:"token operator"}},[t("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("1")]),s._v(">")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("value"),t("span",{pre:!0,attrs:{class:"token operator"}},[t("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("1")]),s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("key"),t("span",{pre:!0,attrs:{class:"token operator"}},[t("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("2")]),s._v(">")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("value"),t("span",{pre:!0,attrs:{class:"token operator"}},[t("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("2")]),s._v(">")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\n")])])]),t("p",[s._v("以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("ENV NODE_VERSION "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("7.2")]),s._v(".0\n\nRUN "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("curl")]),s._v(" -SLO "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"https://nodejs.org/dist/v'),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$NODE_VERSION")]),s._v("/node-v"),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$NODE_VERSION")]),s._v('-linux-x64.tar.xz"')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("\\")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("curl")]),s._v(" -SLO "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"https://nodejs.org/dist/v'),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$NODE_VERSION")]),s._v('/SHASUMS256.txt.asc"')]),s._v("\n")])])]),t("h3",{attrs:{id:"volume"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volume"}},[s._v("#")]),s._v(" VOLUME")]),s._v(" "),t("p",[s._v("定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。")]),s._v(" "),t("p",[s._v("作用：")]),s._v(" "),t("blockquote",[t("p",[s._v("避免重要的数据，因容器重启而丢失，这是非常致命的。\n避免容器不断变大。")])]),s._v(" "),t("p",[t("strong",[s._v("格式：")])]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("VOLUME "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"<路径 1>"')]),s._v(", "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"<路径 2>"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\nVOLUME "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("路径"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n")])])]),t("p",[s._v("在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。")]),s._v(" "),t("h3",{attrs:{id:"expose"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expose"}},[s._v("#")]),s._v(" EXPOSE")]),s._v(" "),t("p",[s._v("仅仅只是声明端口。")]),s._v(" "),t("p",[t("strong",[s._v("作用：")])]),s._v(" "),t("blockquote",[t("p",[s._v("帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。\n在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。\n格式：")])]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("EXPOSE "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("端口 "),t("span",{pre:!0,attrs:{class:"token operator"}},[t("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("1")]),s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("端口 "),t("span",{pre:!0,attrs:{class:"token operator"}},[t("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("2")]),s._v(">")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])])]),t("h3",{attrs:{id:"workdir"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#workdir"}},[s._v("#")]),s._v(" WORKDIR")]),s._v(" "),t("p",[s._v("指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。")]),s._v(" "),t("p",[s._v("docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。")]),s._v(" "),t("p",[s._v("格式：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("WORKDIR "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("工作目录路径"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);